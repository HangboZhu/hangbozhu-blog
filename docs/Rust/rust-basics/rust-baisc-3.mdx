---
title: Rust基础入门-第二章
description: Rust所有权、借用、引用
tags: [rust, code]
sidebar_position: 3
---

import ReferenceList from "@site/src/components/ReferenceList";
import rust from "@site/static/img/icon/rust.png";
import ide from "@site/static/img/icon/ide.png";
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

<img
  className="Badges"
  src="https://img.shields.io/badge/Author-WenjieWei-ff69b4?style=for-the-badge&logo=appveyor"
/>

理解**所有权**和**借用**，是 Rust 学习的核心。

## 所有权

在一门编程语言的设计中，如何申请内存，如何释放内存，是重中之重，也是难点之一。在 CS 发展的过程中，出现了三种流派：

- **垃圾回收机制**`GC`，如 Java、Python 等，在程序运行时不断寻找不使用的内存
- **手动管理分配释放**，如 C++，通过函数调用的方式来申请和释放内存
- **所有权**，如 Rust，通过编译器根据一系列规则检查

第三种，这种检查只会在编译时进行，不会影响程序的运行性能。

### 栈(Stack)和堆(Heap)

栈和堆是核心的数据结构，在之前学习 Python 时，并没有深入了解。但是对于 Rust 这种系统编程语言，值是位于栈上还是堆上，会影响程序的行为和性能。

栈和堆的核心目标是为程序运行时提供可供使用的内存空间。

#### 栈

栈：按照顺序存储并以相反顺序取出，先进后出，后进先出，好比一叠盘子，增加新的盘子，放在最上面，取出盘子，从最上面取出。

增加数据称为**入栈**，取出数据称为**出栈**。

那么根据这种实现方式，栈中的数据需要占用固定大小的内存空间，因为如果数据大小不确定，无法确定数据的位置，也就无法取出数据。

#### 堆

堆：对于大小未知或者可能变化的数据，就可以存储在堆上。

向堆放入数据时，需要先申请一块内存空间，操作系统找到后，将数据放入内存空间，并返回英国表示这个位置地址的**指针**，这个过程称为**分配**。

然后，返回的指针会被入**栈**，因为指针的大小是已知并且固定的，在后续使用中，由在栈上的指针来找到堆上的数据。

#### 性能区别

##### 写入

栈：入栈时，放入栈顶即可
堆：首先操作系统要找空间，并且记录已使用

##### 读取

栈数据可以存在 CPU 的高速缓存中，读取速度快；而堆数据只能存储在内存中，访问速度慢。，并且必须先访问栈，再通过指针访问内存。

#### 所有权和栈堆

当代码中调用一个函数时，函数的参数和局部变量会被压入栈，在函数执行完毕后，会被出栈。

由于堆上的数据没有顺序，所有需要跟踪内存空间的分配和释放，否则会造成内存泄漏。

在 Rust 中，明白堆栈的原理，有助于我们理解所有权的工作原理

### 所有权原则

> 1. 每个值都有一个被称为其所有者的变量。
> 2. 值在任意时刻有且只有一个所有者。
> 3. 当所有者（变量）离开作用域，这个值将被丢弃。

#### 变量作用域

和其他语言类似，作用域是一个变量在程序中有效的范围。

#### String 类型

这里使用`String`类型来说明所有权的工作原理。

`String`并不是字符串类型。在上一章介绍的字符串类型中，字符串字面值是不可变的，被硬编码到程序中，但是并不是每一个字符串的值都是已知的，所以需要一个可变的类型来存储这些值。例如：

```rust
let s = "hello";
```

为此，Rust 标准库提供了`String`类型，可以如下创建：

```rust
let mut s = String::from("hello");
```

### 变量绑定与数据交互

在上一章中，学习了变量的绑定。

#### 转移所有权

在这段代码中：

```rust
let x = 5;
let y = x;
```

这里首先将`i32`整数类型的值`5`绑定到变量`x`上，然后拷贝`x`的值到`y`上。因为`i32 `是 Rust 基本数据类型，大小是固定的，这两个值都是通过栈来存储的，所以拷贝的速度很快。

但是下面这个`String`类型的例子就不一样了：

```rust
let s1 = String::from("hello");
let s2 = s1;
```

刚才提到，`i32`是基本数据类型，大小是固定的，但是`String`类型的值是在堆上分配的，大小是不固定的，因此不会使用自动拷贝来赋值给`s2`。

实际上，`String`类型是一个复杂类型，包含了**存储在栈上的堆指针**、**字符串长度**、\*字符串容量\*\*，其中堆指针指向堆上的字符串数据，容量是指堆上分配的内存大小，长度是指已使用的字符串长度。

## 参考资料

<ReferenceList
  data={[
    {
      title: "Rust语言圣经",
      link: "https://course.rs",
      src: rust,
    },
  ]}
/>
```
